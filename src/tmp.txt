

std::array<std::unique_ptr<RxBlock>,RX_RING_SIZE> rx_ring;
    int rx_ring_front = 0; // current packet
    int rx_ring_alloc = 0; // number of allocated entries

 //
    static inline int modN(int x, int base) {
        return (base + (x % base)) % base;
    }


    // removes the first (oldest) element
    // returns the index of the removed element
    int rxRingPopFront(){
        const auto ret=rx_ring_front;
        rx_ring_front = modN(rx_ring_front + 1, RX_RING_SIZE);
        rx_ring_alloc -= 1;
        assert(rx_ring_alloc >= 0);
        return ret;
    }

    // makes space for 1 new element
    // return its index (this is now the latest element)
    int rxRingPushBack(){
        int idx = modN(rx_ring_front + rx_ring_alloc, RX_RING_SIZE);
        rx_ring_alloc += 1;
        assert(rx_ring_alloc<=RX_RING_SIZE);
        return idx;
    }
    // Peek the oldest element of the rx ring
    int rxRingPeekFront()const{
        return rx_ring_front;
    }
    int rxRingSize()const{
        return rx_ring_alloc;
    }




    // if enough space is available, same like push back
        // if not enough space is available,it drops the oldest block, and also sends any fragments of this block that are not forwarded yet
        int rxRingPushBackSafe() {
            if (rx_ring_alloc < RX_RING_SIZE) {
                return rxRingPushBack();
            }
            //Ring overflow. This means that there are more unfinished blocks than ring size
            //Possible solutions:
            //1. Increase ring size. Do this if you have large variance of packet travel time throught WiFi card or network stack.
            //   Some cards can do this due to packet reordering inside, diffent chipset and/or firmware or your RX hosts have different CPU power.
            //2. Reduce packet injection speed or try to unify RX hardware.

            // remove the oldest block
            auto oldestBlockIdx=rxRingPopFront();
            auto& oldestBlock=*rx_ring[oldestBlockIdx];
            std::cerr<<"Forwarding block that is not yet fully finished "<<oldestBlock.getBlockIdx()<<" with n fragments"<<oldestBlock.getNAvailableFragments()<<"\n";
            forwardMissingPrimaryFragmentsIfAvailable(oldestBlock,false);
            //
            return rxRingPushBack();
        }


// If block is already known and not in the ring anymore return -1
    // else if block is already in the ring return its index or if block is not yet
    // in the ring add as many blocks as needed and then return its index
    int rxRingFindBlockByIdx(const uint64_t blockIdx) {
        // check if block is already in the ring
        for (int i = rx_ring_front, c = rx_ring_alloc; c > 0; i = modN(i + 1, FECDecoder::RX_RING_SIZE), c--) {
            if (rx_ring[i]->getBlockIdx() == blockIdx) return i;
        }

        // check if block is already known and not in the ring then it is already processed
        if (last_known_block != (uint64_t) -1 && blockIdx <= last_known_block) {
            return -1;
        }
        // add as many blocks as we need ( the rx ring mustn't have any gaps between the block indices)
        const int new_blocks = (int) std::min(last_known_block != (uint64_t) -1 ? blockIdx - last_known_block : 1,
                                        (uint64_t) FECDecoder::RX_RING_SIZE);
        assert (new_blocks > 0);

        last_known_block = blockIdx;
        int ring_idx = -1;

        for (int i = 0; i < new_blocks; i++) {
            ring_idx = rxRingPushBackSafe();
            const auto newBlockIdx= blockIdx + i + 1 - new_blocks;
            rx_ring[ring_idx]->repurpose(newBlockIdx);
        }
        return ring_idx;
    }

void processFECBlockWitRxQueue(const uint64_t block_idx, const uint8_t fragment_idx, const std::vector<uint8_t>& decrypted){
        const int ring_idx = rxRingFindBlockByIdx(block_idx);
        //ignore already processed blocks
        if (ring_idx < 0) return;
        // cannot be nullptr
        RxBlock& block = *rx_ring[ring_idx].get();
        // ignore already processed fragments
        if(block.hasFragment(fragment_idx)){
            return;
        }
        block.addFragment(fragment_idx, decrypted.data(), decrypted.size());
        //std::cout<<"Allocated entries "<<rx_ring_alloc<<"\n";

        if (ring_idx == rxRingPeekFront()) {
            // we are in the front of the queue (e.g. at the oldest block)
            // forward packets until the first gap
            forwardMissingPrimaryFragmentsIfAvailable(block);
            // We are done with this block if either all fragments have been forwarded or it can be recovered
            if(block.allPrimaryFragmentsHaveBeenForwarded()){
                // remove block when done with it
                rxRingPopFront();
                return;
            }
            if(block.allPrimaryFragmentsCanBeRecovered()){
                count_p_fec_recovered+=block.reconstructAllMissingData();
                forwardMissingPrimaryFragmentsIfAvailable(block);
                assert(block.allPrimaryFragmentsHaveBeenForwarded());
                // remove block when done with it
                rxRingPopFront();
                return;
            }
            return;
        }else{
            // we are not in the front of the queue but somewhere else
            // If this block can be fully recovered or all primary fragments are available this triggers a flush
            if(block.allPrimaryFragmentsAreAvailable() || block.allPrimaryFragmentsCanBeRecovered()){
                // send all queued packets in all unfinished blocks before and remove them
                while(rxRingPeekFront() != ring_idx){
                    auto tmp=rxRingPopFront();
                    forwardMissingPrimaryFragmentsIfAvailable(*rx_ring[tmp], false);
                }
                // then process the block who is fully recoverable or has no gaps in the primary fragments
                if(block.allPrimaryFragmentsAreAvailable()){
                    forwardMissingPrimaryFragmentsIfAvailable(block);
                    assert(block.allPrimaryFragmentsHaveBeenForwarded());
                }else{
                    // apply fec for this block
                    count_p_fec_recovered+=block.reconstructAllMissingData();
                    forwardMissingPrimaryFragmentsIfAvailable(block);
                    assert(block.allPrimaryFragmentsHaveBeenForwarded());
                }
                // remove block
                rxRingPopFront();
            }
        }
    }


    std::cout<<"Queue size:"<<rx_queue.size()<<"\n";
            if(rx_queue.size()==1){
                std::cout<<"lol"<<rx_queue.front()->getBlockIdx()<<"\n";
            }
            if(found != rx_queue.end()){
                std::cout<<"F\n";
                return found->get();
            }else {
                std::cout<<"Not F\n";
            }











            class FECEncoder{
            public:
                typedef std::function<void(const uint64_t nonce,const uint8_t* payload,const std::size_t payloadSize)> OUTPUT_DATA_CALLBACK;
                OUTPUT_DATA_CALLBACK outputDataCallback;
                // TODO: So we have to be carefully here:
                // 1) If k,n is given: fixed packet size
                // 2) If k,n is not given, but we do variable k,(n) -> what to do ?
                explicit FECEncoder(int k, int n) : fec(k,n){
                    fec_init();
                    //fragments.resize(fec.FEC_N);
                    //for (int i = 0; i < fec.FEC_N; i++) {
                    //    fragments[i] = new uint8_t[FEC_MAX_PACKET_SIZE];
                    //}
                    blockBuffer.resize(std::numeric_limits<uint8_t>::max());
                }
                ~FECEncoder() {
                    //for (int i = 0; i < fec.FEC_N; i++) {
                    //    delete fragments[i];
                    //}
                }
                // K, N is fixed on the encoder side
                const FEC fec;
            private:
                uint64_t currBlockIdx = 0; //block_idx << 8 + fragment_idx = nonce (64bit)
                uint8_t currFragmentIdx = 0;
                size_t currMaxPacketSize = 0;
                //std::vector<uint8_t*> fragments;
                // Pre-allocated to hold all primary and secondary fragments
                std::vector<std::array<uint8_t,FEC_MAX_PACKET_SIZE>> blockBuffer;
            public:
                void encodePacket(const uint8_t *buf,const size_t size) {
                    assert(size <= FEC_MAX_PAYLOAD_SIZE);

                    FECPrimaryFragmentHeader dataHeader(size);
                    // write the size of the data part into each primary fragment.
                    // This is needed for the 'up to n bytes' workaround
                    memcpy(blockBuffer[currFragmentIdx].data(), &dataHeader, sizeof(dataHeader));
                    // write the actual data
                    memcpy(blockBuffer[currFragmentIdx].data() + sizeof(dataHeader), buf, size);
                    // zero out the remaining bytes such that FEC always sees zeroes
                    // same is done on the rx. These zero bytes are never transmitted via wifi
                    const auto writtenDataSize= sizeof(FECPrimaryFragmentHeader) + size;
                    memset(blockBuffer[currFragmentIdx].data() + writtenDataSize, '\0', FEC_MAX_PACKET_SIZE - writtenDataSize);

                    // send primary fragments immediately before calculating the FECs
                    sendBlockFragment(sizeof(dataHeader) + size);
                    // the packet size for FEC encoding is determined by calculating the max of all primary fragments in this block.
                    // Since the rest of the bytes are zeroed out we can run FEC with dynamic packet size.
                    // As long as the deviation in packet size of primary fragments isn't too high the loss in raw bandwidth is negligible
                    // Note,the loss in raw bandwidth comes from the size of the FEC secondary packets, which always has to be the max of all primary fragments
                    // Not from the primary fragments, they are transmitted without the "zeroed out" part
                    currMaxPacketSize = std::max(currMaxPacketSize, sizeof(dataHeader) + size);
                    currFragmentIdx += 1;

                    // once enough data has been buffered, create all the secondary fragments
                    fecEncode(currMaxPacketSize,blockBuffer,fec.N_PRIMARY_FRAGMENTS,fec.N_SECONDARY_FRAGMENTS);

                    // and send all the secondary fragments one after another
                    while (currFragmentIdx < fec.FEC_N) {
                        sendBlockFragment(currMaxPacketSize);
                        currFragmentIdx += 1;
                    }
                    currBlockIdx += 1;
                    currFragmentIdx = 0;
                    currMaxPacketSize = 0;
                }

                // returns true if the block_idx has reached its maximum
                // You want to send a new session key in this case
                bool resetOnOverflow() {
                    if (currBlockIdx > FEC::MAX_BLOCK_IDX) {
                        currBlockIdx = 0;
                        currFragmentIdx=0;
                        return true;
                    }
                    return false;
                }
                // add as many "empty packets" as needed until the block is done
                // if the block is already done,return immediately
                void finishCurrentBlock(){
                    uint8_t emptyPacket[0];
                    while(currFragmentIdx != 0){
                        encodePacket(emptyPacket,0);
                    }
                }
                // returns true if the last block was already fully processed.
                // in this case, you don't need to finish the current block until you put data in the next time
                // also, in the beginning the pipeline is already flushed due to no data packets yet
                bool isAlreadyInFinishedState()const{
                    return currFragmentIdx == 0;
                }
            private:
                // construct WB data packet, from either primary or secondary fragment
                // then forward via the callback
                void sendBlockFragment(const std::size_t packet_size) const {
                    const auto nonce=FEC::calculateNonce(currBlockIdx, currFragmentIdx);
                    const uint8_t *dataP = blockBuffer[currFragmentIdx].data();
                    outputDataCallback(nonce,dataP,packet_size);
                }
            };