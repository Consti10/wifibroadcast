

std::array<std::unique_ptr<RxBlock>,RX_RING_SIZE> rx_ring;
    int rx_ring_front = 0; // current packet
    int rx_ring_alloc = 0; // number of allocated entries

 //
    static inline int modN(int x, int base) {
        return (base + (x % base)) % base;
    }


    // removes the first (oldest) element
    // returns the index of the removed element
    int rxRingPopFront(){
        const auto ret=rx_ring_front;
        rx_ring_front = modN(rx_ring_front + 1, RX_RING_SIZE);
        rx_ring_alloc -= 1;
        assert(rx_ring_alloc >= 0);
        return ret;
    }

    // makes space for 1 new element
    // return its index (this is now the latest element)
    int rxRingPushBack(){
        int idx = modN(rx_ring_front + rx_ring_alloc, RX_RING_SIZE);
        rx_ring_alloc += 1;
        assert(rx_ring_alloc<=RX_RING_SIZE);
        return idx;
    }
    // Peek the oldest element of the rx ring
    int rxRingPeekFront()const{
        return rx_ring_front;
    }
    int rxRingSize()const{
        return rx_ring_alloc;
    }




    // if enough space is available, same like push back
        // if not enough space is available,it drops the oldest block, and also sends any fragments of this block that are not forwarded yet
        int rxRingPushBackSafe() {
            if (rx_ring_alloc < RX_RING_SIZE) {
                return rxRingPushBack();
            }
            //Ring overflow. This means that there are more unfinished blocks than ring size
            //Possible solutions:
            //1. Increase ring size. Do this if you have large variance of packet travel time throught WiFi card or network stack.
            //   Some cards can do this due to packet reordering inside, diffent chipset and/or firmware or your RX hosts have different CPU power.
            //2. Reduce packet injection speed or try to unify RX hardware.

            // remove the oldest block
            auto oldestBlockIdx=rxRingPopFront();
            auto& oldestBlock=*rx_ring[oldestBlockIdx];
            std::cerr<<"Forwarding block that is not yet fully finished "<<oldestBlock.getBlockIdx()<<" with n fragments"<<oldestBlock.getNAvailableFragments()<<"\n";
            forwardMissingPrimaryFragmentsIfAvailable(oldestBlock,false);
            //
            return rxRingPushBack();
        }


// If block is already known and not in the ring anymore return -1
    // else if block is already in the ring return its index or if block is not yet
    // in the ring add as many blocks as needed and then return its index
    int rxRingFindBlockByIdx(const uint64_t blockIdx) {
        // check if block is already in the ring
        for (int i = rx_ring_front, c = rx_ring_alloc; c > 0; i = modN(i + 1, FECDecoder::RX_RING_SIZE), c--) {
            if (rx_ring[i]->getBlockIdx() == blockIdx) return i;
        }

        // check if block is already known and not in the ring then it is already processed
        if (last_known_block != (uint64_t) -1 && blockIdx <= last_known_block) {
            return -1;
        }
        // add as many blocks as we need ( the rx ring mustn't have any gaps between the block indices)
        const int new_blocks = (int) std::min(last_known_block != (uint64_t) -1 ? blockIdx - last_known_block : 1,
                                        (uint64_t) FECDecoder::RX_RING_SIZE);
        assert (new_blocks > 0);

        last_known_block = blockIdx;
        int ring_idx = -1;

        for (int i = 0; i < new_blocks; i++) {
            ring_idx = rxRingPushBackSafe();
            const auto newBlockIdx= blockIdx + i + 1 - new_blocks;
            rx_ring[ring_idx]->repurpose(newBlockIdx);
        }
        return ring_idx;
    }

void processFECBlockWitRxQueue(const uint64_t block_idx, const uint8_t fragment_idx, const std::vector<uint8_t>& decrypted){
        const int ring_idx = rxRingFindBlockByIdx(block_idx);
        //ignore already processed blocks
        if (ring_idx < 0) return;
        // cannot be nullptr
        RxBlock& block = *rx_ring[ring_idx].get();
        // ignore already processed fragments
        if(block.hasFragment(fragment_idx)){
            return;
        }
        block.addFragment(fragment_idx, decrypted.data(), decrypted.size());
        //std::cout<<"Allocated entries "<<rx_ring_alloc<<"\n";

        if (ring_idx == rxRingPeekFront()) {
            // we are in the front of the queue (e.g. at the oldest block)
            // forward packets until the first gap
            forwardMissingPrimaryFragmentsIfAvailable(block);
            // We are done with this block if either all fragments have been forwarded or it can be recovered
            if(block.allPrimaryFragmentsHaveBeenForwarded()){
                // remove block when done with it
                rxRingPopFront();
                return;
            }
            if(block.allPrimaryFragmentsCanBeRecovered()){
                count_p_fec_recovered+=block.reconstructAllMissingData();
                forwardMissingPrimaryFragmentsIfAvailable(block);
                assert(block.allPrimaryFragmentsHaveBeenForwarded());
                // remove block when done with it
                rxRingPopFront();
                return;
            }
            return;
        }else{
            // we are not in the front of the queue but somewhere else
            // If this block can be fully recovered or all primary fragments are available this triggers a flush
            if(block.allPrimaryFragmentsAreAvailable() || block.allPrimaryFragmentsCanBeRecovered()){
                // send all queued packets in all unfinished blocks before and remove them
                while(rxRingPeekFront() != ring_idx){
                    auto tmp=rxRingPopFront();
                    forwardMissingPrimaryFragmentsIfAvailable(*rx_ring[tmp], false);
                }
                // then process the block who is fully recoverable or has no gaps in the primary fragments
                if(block.allPrimaryFragmentsAreAvailable()){
                    forwardMissingPrimaryFragmentsIfAvailable(block);
                    assert(block.allPrimaryFragmentsHaveBeenForwarded());
                }else{
                    // apply fec for this block
                    count_p_fec_recovered+=block.reconstructAllMissingData();
                    forwardMissingPrimaryFragmentsIfAvailable(block);
                    assert(block.allPrimaryFragmentsHaveBeenForwarded());
                }
                // remove block
                rxRingPopFront();
            }
        }
    }


    std::cout<<"Queue size:"<<rx_queue.size()<<"\n";
            if(rx_queue.size()==1){
                std::cout<<"lol"<<rx_queue.front()->getBlockIdx()<<"\n";
            }
            if(found != rx_queue.end()){
                std::cout<<"F\n";
                return found->get();
            }else {
                std::cout<<"Not F\n";
            }



/**
 * @param blockSize Size of each FEC block. Each block must have the same size for FEC.
 * @param primaryFragments list of pointers to raw data chunks (read-only), has to be pre-allocated.
 * @param secondaryFragments list of pointers to raw data chunks (write-only), has to be pre-allocated.
 * As many fec_blocks pointers as supplied here, this many fec secondary packets will be generated
 */
void fecEncode(unsigned int blockSize, const std::vector<const uint8_t*>& primaryFragments,const std::vector<uint8_t*>& secondaryFragments){
    fec_encode(blockSize, (const unsigned char**)primaryFragments.data(), primaryFragments.size(), (unsigned char**)secondaryFragments.data(), secondaryFragments.size());
}




struct X1{
    uint8_t isPrimaryF:1;
    uint16_t packetSize:15;
}__attribute__ ((packed));
static_assert(sizeof(X1) == 2, "ALWAYS_TRUE");

struct X2{
    uint8_t isPrimaryF:1;
    uint16_t nProtectedPrimaryFragments:15;
};
static_assert(sizeof(X2) == 2, "ALWAYS_TRUE");

// With each FEC secondary packet comes the information how many primary fragments it protects.
// This number is the same for each secondary fragment in a block, but since we don't know which secondary fragment we might loose beforehand
// It has to be duplicated with each secondary fragment.


struct extraData{
    uint8_t isSecondaryFragment:1;
    // if this is a primary fragment (first bit not set): primary fragment index
    // if this is a secondary fragment (first bit set): secondary fragment index ( ? bits + n of protected primary fragments)
    uint32_t fragmentIdx : 31;
};


static uint64_t calculateNonce(const uint32_t blockIdx,const uint16_t fragmentIdx,const uint16_t extradata){
        uint64_t ret;
        memcpy(&((uint8_t*)&ret)[0],&blockIdx,sizeof(blockIdx));
        memcpy(&((uint8_t*)&ret)[sizeof(blockIdx)],&fragmentIdx,sizeof(fragmentIdx));
        memcpy(&((uint8_t*)&ret)[sizeof(blockIdx)+sizeof(fragmentIdx)],&extradata,sizeof(extradata));
        return ret;
    }

     /*uint64_t ret;
            memcpy(&ret,this,sizeof(uint64_t));
            return ret;*/

// conversion from / to nonce
    /*static uint64_t calculateNonce(const uint64_t blockIdx, const uint8_t fragmentIdx){
        assert(blockIdx <= MAX_BLOCK_IDX); // should never happen
        return htobe64(((blockIdx & BLOCK_IDX_MASK) << 8) + fragmentIdx);
    }
    static uint64_t calculateBlockIdx(const uint64_t nonce){
        return be64toh(nonce) >> 8;
    }
    static uint8_t calculateFragmentIdx(const uint64_t nonce){
        return (uint8_t) (be64toh(nonce) & 0xff);
    }*/

     // Helper functions
        // nonce:  56bit block_idx + 8bit fragment_idx
        //static constexpr auto BLOCK_IDX_MASK=((1LLU << 56) - 1);
        //static constexpr uint64_t MAX_BLOCK_IDX=((1LLU << 55) - 1);

        //fec_decode(maxPacketSizeOfThisBlock, primaryFragmentsData.data(), fec.FEC_K, secondaryFragmentsData.data(), indicesAvailableSecondaryFragments.data(), indicesMissingPrimaryFragments.data(), indicesAvailableSecondaryFragments.size());


        // send primary fragments immediately before calculating the FECs
                sendBlockFragment(sizeof(dataHeader) + size);
                // the packet size for FEC encoding is determined by calculating the max of all primary fragments in this block.
                // Since the rest of the bytes are zeroed out we can run FEC with dynamic packet size.
                // As long as the deviation in packet size of primary fragments isn't too high the loss in raw bandwidth is negligible
                // Note,the loss in raw bandwidth comes from the size of the FEC secondary packets, which always has to be the max of all primary fragments
                // Not from the primary fragments, they are transmitted without the "zeroed out" part
                currMaxPacketSize = std::max(currMaxPacketSize, sizeof(dataHeader) + size);
                currFragmentIdx += 1;

                //std::cout<<"Fragment index is "<<(int)fragment_idx<<"FEC_K"<<(int)FEC_K<<"\n";
                if (currFragmentIdx < fec.FEC_K) {
                    return;
                }
                // once enough data has been buffered, create all the secondary fragments
                fecEncode(currMaxPacketSize,blockBuffer,fec.N_PRIMARY_FRAGMENTS,fec.N_SECONDARY_FRAGMENTS);

                // and send all the secondary fragments one after another
                while (currFragmentIdx < fec.FEC_N) {
                    sendBlockFragment(currMaxPacketSize);
                    currFragmentIdx += 1;
                }
                currBlockIdx += 1;
                currFragmentIdx = 0;
                currMaxPacketSize = 0;

//const uint64_t packet_seq = block.calculateSequenceNumber(fragmentIdx);

        //if (packet_seq > seq + 1) {
        //    const auto packetsLost=(packet_seq - seq - 1);
            //std::cerr<<packetsLost<<"packets lost\n";
        //    count_p_lost += packetsLost;
        //}
        //seq = packet_seq;
        //std::cout<<block.getNAvailableFragments()<<" "<<block.nAvailablePrimaryFragments<<" "<<block.nAvailableSecondaryFragments<<"\n";
        //std::cout<<fec.N_PRIMARY_FRAGMENTS<<" "<<fec.N_SECONDARY_FRAGMENTS<<"\n";

std::cerr<<"Use K=0 only in combination with N=0.\n"
                       "This is an advanced option that removes duplicates, but doesn't check for packet order.\n"
                       "(UDP also allows duplicates but we want to get rid of duplicates as fast as possible to save memory bandwidth)\n."
                       "Latency overhead is 0 in this mode.\n"
                       "If you don't know what this means, use FEC_K==1 and FEC_N==1 for no duplicates and no packet re-ordering.\n";

 {3,5},{3,6},{6,8},{6,9},
                {6,12},{8,16},{12,24},
                {4,6},{12,14},
                {40,60},
                {100,150},
                {120,240}

 // How to use with fixed block size:
    // Just use m
    // This constructor is for fixed packet size
    /*FECEncoder(int k, int n):BLOCK_SIZE_DYNAMIC(false),FEC_K_FIXED(k),FEC_N_FIXED(n){
        assert(n>=k);
        assert(n>0);
        assert(k>0);
        assert(k<=MAX_N_P_FRAGMENTS_PER_BLOCK);
        assert(n<=MAX_N_P_FRAGMENTS_PER_BLOCK+MAX_N_S_FRAGMENTS_PER_BLOCK);
        fec_init();
        blockBuffer.resize(n);
        std::cout<<"FEC fixed (K:N)=("<<k<<":"<<n<<")"<<"\n";
    }*/

  // And this constructor is for dynamic block size, which means the FEC step is applied after either we run out
    // of possible fragment indices or call encodePacket(...,endBlock=true)
    /*FECEncoder(int percentage):BLOCK_SIZE_DYNAMIC(true),PERCENTAGE(percentage){
        assert(percentage<=100);
        fec_init();
        blockBuffer.resize(MAX_TOTAL_FRAGMENTS_PER_BLOCK);
    }*/

void forceForwardBlocksOlderThan(const std::chrono::nanoseconds& maxLatency){
        // loop through all blocks in queue. If we find a block that is older than N ms
        // "forward it" even though it is missing packets
        // get the age in nanoseconds of the currently "oldest" block
    }

 //int idx=fec_k;
         /*while (indicesAvailableSecondaryFragments.size()<nMissingPrimaryFragments){
             if(fragment_map[idx]==AVAILABLE){
                 indicesAvailableSecondaryFragments.push_back(idx);
             }
             idx++;
         }*/
std::cout<<"block_idx"<<blockIdx<<" k:"<<fec_k<<" X1:"<<indicesAvailableSecondaryFragments.size()<<" X2:"<<nAvailableSecondaryFragments<<"\n";

/**
 * create 2 arrays of data pointers.
 * First one holds pointers to all primary fragments (index 0 = first primary fragment, index 1= second primary fragment, ...
 * And second one holds pointers to all secondary fragments ( index 0 = first secondary fragment, index 1 = second secondary fragment, ...
 */
template<std::size_t S>
std::pair<std::vector<uint8_t*>,std::vector<uint8_t*>> splitBlockBuffer(std::vector<std::array<uint8_t,S>>& blockBuffer, unsigned int nPrimaryFragments){
    std::vector<uint8_t*> primaryFragmentsP(nPrimaryFragments);
    for(unsigned int i=0;i<nPrimaryFragments;i++){
        primaryFragmentsP[i]=blockBuffer[i].data();
    }
    const int nSecondaryFragmentsPointers=blockBuffer.size()-nPrimaryFragments;
    std::vector<uint8_t*> secondaryFragmentsP(nSecondaryFragmentsPointers);
    for(unsigned int i=0;i<nSecondaryFragmentsPointers;i++){
        secondaryFragmentsP[i]=blockBuffer[nPrimaryFragments+i].data();
    }
    return std::make_pair(primaryFragmentsP,secondaryFragmentsP);
}

 /*const int nSecondaryFragmentsPointers=blockBuffer.size()-nPrimaryFragments;
    std::vector<uint8_t*> secondaryFragmentsP(nSecondaryFragmentsPointers);
    for(unsigned int i=0;i<nSecondaryFragmentsPointers;i++){
        secondaryFragmentsP[i]=blockBuffer[nPrimaryFragments+i].data();
    }*/

    //std::vector<uint8_t*> primaryFragmentsP(nPrimaryFragments);
        //for(unsigned int i=0;i<nPrimaryFragments;i++){
        //    primaryFragmentsP[i]=blockBuffer[i].data();
        //}
 /*std::vector<uint8_t*> primaryFragments(nPrimaryFragments);
    for(unsigned int i=0;i<nPrimaryFragments;i++){
        primaryFragments[i]=blockBuffer[i].data();
    }
    // n of all theoretically possible locations for secondary fragments (could be optimized if the full range is not used)
    const auto nTheoreticalSecondaryFragments=blockBuffer.size()-nPrimaryFragments;
    std::vector<uint8_t*> secondaryFragments(nTheoreticalSecondaryFragments);
    for(unsigned int i=0;i<nTheoreticalSecondaryFragments;i++){
        secondaryFragments[i]=blockBuffer[nPrimaryFragments+i].data();
    }
    fec_decode(packetSize, primaryFragments.data(), nPrimaryFragments, secondaryFragments.data(), indicesAvailableSecondaryFragments.data(), indicesMissingPrimaryFragments.data(), indicesAvailableSecondaryFragments.size());*/

//auto tmp=fec_new(primaryFragments.size(),primaryFragments.size()+secondaryFragments.size());
    //fec_encode(tmp,(const gf**)primaryFragments.data(),(gf**)secondaryFragments.data(),fragmentSize);
    //fec_free(tmp);
    //auto tmp=fec_new(4,8);

/*std::vector<uint8_t*> fuuSec;
    for(const auto& idx:indicesAvailableSecondaryFragments){
        fuuSec.push_back(secondaryFragments[idx]);
    }
    fec_decode(fragmentSize,(unsigned char**)primaryFragments.data(), primaryFragments.size(),(unsigned char**)fuuSec.data(),
               (unsigned int*)indicesAvailableSecondaryFragments.data(),(unsigned int*)indicesMissingPrimaryFragments.data(), indicesMissingPrimaryFragments.size());*/

 /*auto tmp=fec_new(primaryFragments.size(),primaryFragments.size()+secondaryFragments.size());
    std::vector<uint8_t*> block=primaryFragments;
    for(const auto el:secondaryFragments){
        block.push_back(el);
    }
    fec_decode(tmp,b)*/

 /*auto receivedPrimaryFragmentIndices=std::vector<unsigned int>({
                //0,
                1,
                2,
                3,
                4,
                5,
                6,
                7
            });*/

    //std::cout<<"YindicesMissingPrimaryFragments:"<<StringHelper::vectorAsString(indicesMissingPrimaryFragments)<<"\n";
    //std::cout<<"YindicesAvailableSecondaryFragments:"<<StringHelper::vectorAsString(indicesAvailableSecondaryFragments)<<"\n";
            //auto receivedSecondaryFragmentIndices=std::vector<unsigned int>({0});
            //auto receivedSecondaryFragmentIndices=GenericHelper::createIndices(nSecondaryFragments);

template<std::size_t S>
void fecDecode2(unsigned int packetSize, std::vector<std::array<uint8_t,S>>& blockBuffer, unsigned int nPrimaryFragments,
                const std::vector<unsigned int>& indicesAvailablePrimaryFragments, const std::vector<unsigned int>& indicesAvailableSecondaryFragments){
    assert(indicesAvailablePrimaryFragments.size() + indicesAvailableSecondaryFragments.size() == nPrimaryFragments);
    // the fec impl. wants the indices of missing primary fragments, not those ones available
    std::vector<unsigned int> indicesMissingPrimaryFragments;
    for(unsigned int i=0;i<nPrimaryFragments;i++){
        auto found= indicesAvailablePrimaryFragments.end() != std::find(indicesAvailablePrimaryFragments.begin(), indicesAvailablePrimaryFragments.end(), i);
        if(!found){
            indicesMissingPrimaryFragments.push_back(i);
        }
    }
    assert(indicesMissingPrimaryFragments.size()== nPrimaryFragments - indicesAvailablePrimaryFragments.size());
    std::cout<<"indicesMissingPrimaryFragments:"<<StringHelper::vectorAsString(indicesMissingPrimaryFragments)<<"\n";

    //
    auto primaryFragmentP=GenericHelper::convertToP(blockBuffer,0,nPrimaryFragments);
    auto secondaryFragmentP=GenericHelper::convertToP(blockBuffer,nPrimaryFragments,blockBuffer.size()-nPrimaryFragments);

    std::vector<unsigned int> indicesAvailableSecondaryFragmentsAdjusted(indicesAvailableSecondaryFragments.size());
    for(int i=0; i < indicesAvailableSecondaryFragments.size(); i++){
        indicesAvailableSecondaryFragmentsAdjusted[i]= indicesAvailableSecondaryFragments[i] - nPrimaryFragments;
    }
    std::cout<<"indicesAvailableSecondaryFragmentsAdjusted:"<<StringHelper::vectorAsString(indicesAvailableSecondaryFragmentsAdjusted)<<"\n";

    fec_decode(packetSize, primaryFragmentP, secondaryFragmentP, indicesMissingPrimaryFragments, indicesAvailableSecondaryFragmentsAdjusted);

    //fec_decode(packetSize,primaryFragmentPointers.data(),nPrimaryFragments,secondaryFragmentPointers.data(),indicesAvailableSecondaryFragmentsAdjusted.data(),indicesMissingPrimaryFragments.data(),indicesAvailableSecondaryFragmentsAdjusted.size());

}